import streamlit as st
import os
import requests
import json
import base64
import pickle
import datetime

# Hidden configuration file path
CONFIG_FILE_PATH = os.path.join(os.path.expanduser("~"), ".config", "tts_app.bin")

DEFAULT_API_KEY = "sk_df1301a9a3b9071df7f1cc8ffe18e988c08848ebab46fdc5"
DEFAULT_CHARACTER_LIMIT = 500
BASE_URL = "https://api.elevenlabs.io/v1"

def create_config_file():
    """Creates a secure config file to store app usage data and settings."""

    # Extensive description for user warning and instructions
    comments = (
        "# WARNING: This file is automatically generated by the TTS app.\n"
        "# Do NOT delete or modify this file manually. It stores important configuration data and\n"
        "# usage statistics necessary for the app's functionality. Deleting or altering this file\n"
        "# may lead to loss of data, errors, or unintended consequences.\n"
        "# If you need to reset or change any configuration, please use the app interface.\n\n"
    )
    # Create a directory if it does not exist
    os.makedirs(os.path.dirname(CONFIG_FILE_PATH), exist_ok=True)

    # Initialize config data
    config_data = {
        "user_api_key": "",
        "available_voices": [],
        "tts_history": [],
        "character_limit": DEFAULT_CHARACTER_LIMIT,
        "used_characters": 0
    }

    # Save the config file with description
    with open(CONFIG_FILE_PATH, "wb") as file:
        file.write(comments.encode('utf-8'))
        pickle.dump(config_data, file)

def load_config_file():
    """Loads the configuration data from the secure config file."""
    if not os.path.exists(CONFIG_FILE_PATH):
        create_config_file()

    try:
        with open(CONFIG_FILE_PATH, "rb") as file:
            # Skip the comments at the top
            file_content = file.read().split(b'\n\n', 1)[1]
            config_data = pickle.loads(file_content)
    except Exception as e:
        st.error(f"Error loading config file: {e}")
        config_data = {
            "user_api_key": "",
            "available_voices": [],
            "tts_history": [],
            "character_limit": DEFAULT_CHARACTER_LIMIT,
            "used_characters": 0
        }
        save_config_file(config_data)

    return config_data

def save_config_file(config_data):
    """Saves the configuration data to the secure config file."""
    try:
        with open(CONFIG_FILE_PATH, "rb") as file:
            comments = file.read().split(b'\n\n', 1)[0]

        with open(CONFIG_FILE_PATH, "wb") as file:
            file.write(comments + b'\n\n')
            pickle.dump(config_data, file)
    except Exception as e:
        st.error(f"Error saving config file: {e}")

def get_available_voices(api_key):
    """Fetch the list of available voices using Eleven Labs API."""
    headers = {
        "Accept": "application/json",
        "xi-api-key": api_key,
        "Content-Type": "application/json"
    }
    response = requests.get(f"{BASE_URL}/voices", headers=headers)

    if response.status_code == 200:
        try:
            return response.json().get('voices', [])
        except json.JSONDecodeError:
            st.error("Error parsing voices response.")
            return []
    else:
        st.error(f"Error fetching voices: {response.status_code} - {response.text}")
        return []

def text_to_speech(api_key, text, model_id, voice_id, stability, similarity, style, speaker_boost, output_file='Demo_Audio_Sample.wav'):
    """Convert text to speech using Eleven Labs API with customizable parameters."""
    tts_url = f'{BASE_URL}/text-to-speech/{voice_id}'
    headers = {
        'Content-Type': 'application/json',
        'xi-api-key': api_key,
    }
    payload = {
        'text': text,
        'model_id': model_id,
        'voice_settings': {
            'stability': stability,
            'similarity_boost': similarity,
            'style' : style,
            'use_speaker_boost': speaker_boost,
        }
    }

    response = requests.post(tts_url, headers=headers, data=json.dumps(payload))

    if response.status_code == 200:
        # Save the output audio file
        with open(f"audios\\{output_file}", 'wb') as f: 
            f.write(response.content)
        st.success(f"Audio saved to {output_file}")
        st.audio(f"audios\\{output_file}", format="audio/wav")
    else:
        st.error(f"Error: {response.status_code} - {response.text}")

def main():
    st.title("Eleven Labs Text-to-Speech Generator")

    # Load config data
    config_data = load_config_file()

    # API Key Section
    st.sidebar.header("API Key Settings")
    if st.sidebar.checkbox("Use default API key"):
        api_key = DEFAULT_API_KEY
        is_default_key = True
    else:
        api_key = st.sidebar.text_input("Enter your Eleven Labs API key", type="password",)
        is_default_key = False

    if not is_default_key:
        if st.sidebar.button("Save"):
            st.success("API key changed successfully.")

        if not api_key:
            st.warning("Please provide an API key to continue.")
            return

    # TTS Mode Selection
    st.sidebar.header("Model")
    model = st.sidebar.selectbox("Select TTS Model", ["Eleven Multilingual V2", "Eleven Turbo V2_5", "Eleven Turbo V2", "Eleven Monolingual V1", "Eleven Multilingual V1"])
    models = {
        "Eleven Multilingual V2" : "eleven_multilingual_v2",
        "Eleven Turbo V2_5" : "eleven_turbo_v2_5",
        "Eleven Turbo V2" : "eleven_turbo_v2",
        "Eleven Monolingual V1" : "eleven_monolingual_v1",
        "Eleven Multilingual V1" : "eleven_multilingual_v1"
    }
    model_id = models[model]
    # Fetch available voices
    voices = get_available_voices(api_key)
    config_data["available_voices"] = voices
    save_config_file(config_data)

    if not voices:
        st.warning("No voices available. Check your API key and try again.")
        return

    voice_options = {voice['name']: voice['voice_id'] for voice in voices}
    voice_name = st.selectbox("Select a Voice", list(voice_options.keys()))
    voice_id = voice_options[voice_name]

    # Input text for TTS
    text = st.text_area("Enter the text to convert to speech", height=150)

    # Check character limit for default API key
    if is_default_key and len(text) > DEFAULT_CHARACTER_LIMIT:
        st.error(f"Character limit exceeded. Maximum {DEFAULT_CHARACTER_LIMIT} characters allowed for default API key.")
        return

    # Customization parameters for TTS
    st.sidebar.header("Customization Parameters")
    # Stability
    stability = st.sidebar.slider("Stability", 0.0, 1.0, 0.5, help="More variable to More stable")
    # Similarity
    similarity = st.sidebar.slider("Similarity Boost", 0.0, 1.0, 0.75, help="Low to High")
    # Style
    style = st.sidebar.slider("Style Exaggeration", 0.0, 1.0, 0.0, help="None to Exaggerated")
    # Speaker Boost
    speaker_boost = st.sidebar.checkbox("Speaker Boost")

    # Time
    time = datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S")
    time_file = datetime.datetime.now().strftime("%d%m%Y %H%M%S")
    output_file = f"Demo_Audio_Sample_{time_file}.wav"

    # Convert text to speech
    if st.button("Generate Speech"):
        with st.spinner("Generating Speech..."):
            if text.strip():
                config_data["tts_history"].append({
                    "text": text,
                    "voice": voice_name,
                    "model": model_id,
                    "parameters": {"stability": stability, "similarity": similarity, "style": style, "speaker_boost": speaker_boost},
                    "time" : time,
                    "output_file" : output_file,
                })
                config_data["used_characters"] += len(text)
                save_config_file(config_data)
                DEFAULT_CHARACTER_LIMIT -= len(text)
                text_to_speech(api_key, text, model_id, voice_id, stability, similarity, style, speaker_boost, output_file=output_file)
            else:
                st.error("Please enter some text to convert.")
    
if __name__ == "__main__":
    main()
